<?php/*SQL TABLE DEPENDENCIES:AuthAttemptUserAuthDetailUserAccountPersonalDetail*//* TODO: class file needs clean up */require("lib/UserRole.php");class Authentication{    private static $instance;    private $loginResponse = "";    private $auth_db;    public function __construct()    {//(email,password)        $args = func_get_args();        $this->auth_db = new DB();//TODO:possibly state the connection type in argument        if (isset($args[0], $args[1])) {            $this->loginUser($args[0], $args[1]);        }        Session::secureStart();    }    private function checkBrute($user_id)    {        // Get timestamp of current time        $now = time();        // All login attempts are counted from the past 2 hours.        $valid_attempts = $now - (2 * 60 * 60);        if ($stmt = $this->auth_db->prepare("SELECT timeAttempted FROM AuthAttempt        WHERE user_ID = :user_ID AND timeAttempted > :valid_attempts")        ) {            $stmt->bindParam("user_ID", $user_id, PDO::PARAM_INT);            $stmt->bindParam("valid_attempts", $valid_attempts, PDO::PARAM_INT);            $stmt->execute();            // If there has been more than 5 failed auth attempts            if ($stmt->rowCount() > 5) {                return true;            } else {                return false;            }        }    }    public static function getAuthToken()    {        $headers = apache_request_headers();        $auth_token = null;        if (isset($_GET['auth_token'])) {            $auth_token=$_GET['auth_token'];        }elseif (isset($headers[AUTH_TOKEN_HEADER])) {            $auth_token = $headers[AUTH_TOKEN_HEADER];        } else $auth_token = Session::get(CN_AUTH_TOKEN);        return $auth_token;    }    private function storeAuthDetails($user_id, $user_role)    {        $user_id = preg_replace("/[^0-9]+/", "", $user_id); // XSS protection as we might print this value        //$username = preg_replace("/[^a-zA-Z0-9_\-]+/", "", $username); // XSS protection as we might print this value        $auth_token = self::generateAuthToken($user_id, $user_role);        Session::set(CN_AUTH_TOKEN, $auth_token, time() + 3600 * 24 * 30);///expires in 30 days        Session::set(CN_USER_ID, $user_id, time() + 3600 * 24 * 30);///expires in 30 days        Session::set(CN_USER_ROLE, $user_role, time() + 3600 * 24 * 30);///expires in 30 days        return true;    }    public static function generateSalt()    {        return hash('sha512', rand(0, 99999));//TODO: ADD MORE SECURITY    }    public static function generateSaltedPassword($password, $salt)    {        return hash('sha512', $password . $salt);    }    private static function generateAuthToken($user_ID, $user_role)    {        $auth_token = hash('sha512', $user_ID . "FSDFHJSHFJKSDHFJKSDFSDFSJKFJDHFJ" . $user_role . "KSHDFJK54J3453845738945JHKXGHJKGHJKDF");///TODO: HAVE CODE REGENERATE EVERY SO OFTEN TO FORCE AUTH TOKEN EXPIRATION        $dir = A_DIR . $auth_token . ".token";        if (!file_exists($dir))            if (!file_put_contents($dir, '{"user_id":' . $user_ID . ',"user_role":' . $user_role . '}')) throw new AuthFailure("Failed to create token");        return $auth_token;    }    private function checkPersonalEmailExists($personalEmail)    {        $sth = $this->auth_db->prepare("SELECT COUNT(*) FROM UserAuthDetail WHERE personalEmail=:personalEmail");        $sth->bindParam("personalEmail", $personalEmail, PDO::PARAM_STR);        if ($sth->execute()) {            if ($sth->fetchColumn() > 0) {                return true;//personal email already exists            }        } else throw new SQLFailure("Failed to connect with Server");        return false;    }    private static function authUserDetailSessions()    {        $regAuthToken = self::generateAuthToken(Session::get(CN_USER_ID), Session::get(CN_USER_ROLE));///get the auth token b        return (self::getAuthToken() == $regAuthToken);    }    private static function getUserAccountDetails() {        $auth_token=self::getAuthToken();        if (!empty($auth_token)&&file_exists(A_DIR.$auth_token.".token")) {            $userDetails=file_get_contents(A_DIR.$auth_token.".token");            $details=json_decode($userDetails);            if (isset($details->user_id,$details->user_role)) {                return $details;            }else throw new AuthFailure("Invalid or corrupt Token");        }else throw new AuthFailure();    }    public static function authorizeAccessLevel($minimumUserRoleAccessLevel)    {        if ($minimumUserRoleAccessLevel > self::getUserRole()) throw new AuthFailure("You do not have permission to make these changes");    }    public function loginUser($email, $password)    {        try {            if (strlen($email) < 3) throw new LoginFailure("Invalid Email Specified");            if ($stmt = $this->auth_db->prepare("SELECT user_ID, user_password, user_password_salt,user_role FROM UserAuthDetail WHERE personalEmail=:email LIMIT 1")) {                $stmt->bindParam("email", $email, PDO::PARAM_STR);                if ($stmt->execute()) {                } else throw new SQLFailure($stmt);                if ($stmt->rowCount() <= 0) throw new LoginFailure("User not registered on the system");                $row = $stmt->fetch(PDO::FETCH_ASSOC);                $user_id = $row["user_ID"];                $db_password = $row["user_password"];                $user_role = $row['user_role'];                $salt = $row["user_password_salt"];                if (strlen($db_password) <= 0) {/*TODO: EXCEPTION: LOGIN DB FAILURE*/                    throw new HighException("A fatal error has occurred and cannot log you in at this time");                }                //TODO: HANDLE PASSWORD ALREADY ENCRYPTED                $password = self::generateSaltedPassword($password, $salt);                if ($stmt->rowCount() == 1) { // If the user exists                    // We check if the account is locked from too many login attempts                    if ($this->checkBrute($user_id) == true) {                        /* TODO: ADD ACTIVITY OF ACCOUNT BEING LOCKED */                        throw new LoginFailure("Account has been locked");                        // Account is locked                        // Send an email to user saying their account is locked                    } else {                        if ($db_password == $password) { // Check if the password in the database matches the password the user submitted.                            // Password is correct!                            if ($user_role != UserRole::USER_ADMINISTRATOR && !$this->checkVerifiedEmail($user_id)) {                                throw new LoginFailure("Email for this account has not been verified yet!");                            }                            if ($user_role != UserRole::USER_ADMINISTRATOR && !$this->checkAccountActivated($user_id)) {                                throw new LoginFailure("Account has not been activated yet!");                            }                            $this->storeAuthDetails($user_id, $user_role);//generate auth token and create cookies etc.                            // Login successful.                            return true;                        } else {                            $now = time();                            $addRecord = $this->auth_db->prepare("INSERT INTO AuthAttempt (user_ID, timeAttempted) VALUES (:user_ID,:now)");                            $addRecord->bindParam("user_ID", $user_id, PDO::PARAM_INT);                            $addRecord->bindParam("now", $now, PDO::PARAM_INT);                            if (!$addRecord->execute()) {                                throw new HighException("Failed to record Auth attempt");                            }                            //TODO: AMEND HighException handler so code proceeds to execute normally                            throw new LoginFailure("Email and/or password is invalid.");                        }                    }                } else {                    // No user exists.                    throw new LoginFailure("Email and/or password is invalid.");                }            } else {                /* TODO: add error log 'Failed to connect to server for authentication!' */                throw new LoginFailure("Error connecting to server!");            }        } catch (PDOException $exc) {            throw new LoginFailure("Could not connect to server");        }    }    public static function getUserID()    {        $detail=self::getUserAccountDetails();        return $detail->user_id;    }    public static function getUserRole()    {        $detail=self::getUserAccountDetails();        return $detail->user_role;    }    public function validateAuthToken($auth_token = null, $user_role = null, $user_id = null)    {        $auth_token = empty($auth_token) ? self::getAuthToken() : $auth_token;        if (empty($auth_token)) return false;        $auth_token_dir = A_DIR . $auth_token . ".token";        if (!file_exists($auth_token_dir)) return false;        if ($userInfo = file_get_contents($auth_token_dir)) {            $userInfo = json_decode($userInfo);            if (isset($userInfo->user_role, $userInfo->user_id)) return true;        }        return false;    }    public function getLoginResponse()    {        return $this->loginResponse;    }    public static function logout()    {        // Unset all session values        $_SESSION = array();        // get session parameters        $params = session_get_cookie_params();        // Delete the actual cookie.        setcookie(session_name(), '', time() - 42000, $params["path"], $params["domain"], $params["secure"], $params["httponly"]);        Session::delete(CN_AUTH_TOKEN);        Session::delete(CN_USER_ID);        Session::delete(CN_USER_ROLE);        // Destroy session        $token_dir=A_DIR.self::getAuthToken().".token";        if (file_exists($token_dir))            if (!unlink($token_dir)) return false;        return true;    }    public static function init()    {        if (is_null(self::$instance)) {            self::$instance = new Authentication();        }        return self::$instance;    }}